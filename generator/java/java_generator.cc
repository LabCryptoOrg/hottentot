/*  The MIT License (MIT)
 *
 *  Copyright (c) 2015 Noavaran Tejarat Gostar NAEEM Co.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *  
 *  The above copyright notice and this permission notice shall be included in all
 *  copies or substantial portions of the Software.
 *  
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *  SOFTWARE.
 */

#include "java_generator.h"
#include "../ds/hot.h"
#include <stdint.h>
 #include <sys/stat.h>

namespace naeem {
  namespace hottentot {
    namespace generator {
      namespace java {

      	JavaGenerator::~JavaGenerator(){
      		for(int i = 0 ; i < modules_.size() ; i++){
      			::naeem::hottentot::generator::ds::Module* pModule = modules_.at(i);
      			for(int j = 0 ; j < pModule->structs_.size() ; j++){
      				::naeem::hottentot::generator::ds::Struct* pStruct = pModule->structs_.at(j);
      				for(int k = 0 ; k < pStruct->declarations_.size() ; k++){
						delete pStruct->declarations_.at(k);
      				}
      				delete pStruct;
      			}
      			delete pModule;
      		}
      	}
      	
		void
		JavaGenerator::Generate(::naeem::hottentot::generator::ds::Hot *hot,
				        ::naeem::hottentot::generator::GenerationConfig &generationConfig) {

			outDir_ = generationConfig.outDir_;
			struct stat st = {0};
	        if(stat(outDir_.c_str(),&st) != 0){
	                mkdir(outDir_.c_str(),0777);
	        }
			MakeStringsFromByteArrays();
		    //ReadTemplateFiles();
		    
		    //outDir_ = "/home/developer/Desktop/generated";

		     //::naeem::hottentot::generator::ds::Struct *pStruct;
		     modules_ = hot->modules_;
		     for (int i = 0; i < modules_.size(); i++) {
		         ::naeem::hottentot::generator::ds::Module *pModule = modules_.at(i);
		         GenerateStructs(pModule);
		         GenerateAbstractService(pModule);
		         GenerateServiceInterface(pModule);		        
		         GenerateRequestHandler(pModule);
		         GenerateServiceProxyBuilder(pModule);
		         GenerateServiceProxy(pModule);
		         
		     }
		    //std::cout << hot->GetModules().at(0)->GetMethod()-> << std::endl;
		    std::cout << "Java Generation done." << std::endl;
		}

		void 
		JavaGenerator::MakeStringsFromByteArrays(){
			//service proxy
			unsigned char serviceProxyByteArray[] = {
            0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x20, 0x5b, 0x25, 0x42, 0x41,
            0x53, 0x45, 0x5f, 0x50, 0x41, 0x43, 0x4b, 0x41, 0x47, 0x45, 0x5f, 0x4e,
            0x41, 0x4d, 0x45, 0x25, 0x5d, 0x3b, 0x0a, 0x0a, 0x69, 0x6d, 0x70, 0x6f,
            0x72, 0x74, 0x20, 0x69, 0x72, 0x2e, 0x6e, 0x74, 0x6e, 0x61, 0x65, 0x65,
            0x6d, 0x2e, 0x68, 0x6f, 0x74, 0x74, 0x65, 0x6e, 0x74, 0x6f, 0x74, 0x2e,
            0x72, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x2e, 0x41, 0x72, 0x67, 0x75,
            0x6d, 0x65, 0x6e, 0x74, 0x3b, 0x0a, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74,
            0x20, 0x69, 0x72, 0x2e, 0x6e, 0x74, 0x6e, 0x61, 0x65, 0x65, 0x6d, 0x2e,
            0x68, 0x6f, 0x74, 0x74, 0x65, 0x6e, 0x74, 0x6f, 0x74, 0x2e, 0x72, 0x75,
            0x6e, 0x74, 0x69, 0x6d, 0x65, 0x2e, 0x50, 0x72, 0x6f, 0x78, 0x79, 0x3b,
            0x0a, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x20, 0x69, 0x72, 0x2e, 0x6e,
            0x74, 0x6e, 0x61, 0x65, 0x65, 0x6d, 0x2e, 0x68, 0x6f, 0x74, 0x74, 0x65,
            0x6e, 0x74, 0x6f, 0x74, 0x2e, 0x72, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65,
            0x2e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x3b, 0x0a, 0x69, 0x6d,
            0x70, 0x6f, 0x72, 0x74, 0x20, 0x69, 0x72, 0x2e, 0x6e, 0x74, 0x6e, 0x61,
            0x65, 0x65, 0x6d, 0x2e, 0x68, 0x6f, 0x74, 0x74, 0x65, 0x6e, 0x74, 0x6f,
            0x74, 0x2e, 0x72, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x2e, 0x52, 0x65,
            0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x3b, 0x0a, 0x69, 0x6d, 0x70, 0x6f,
            0x72, 0x74, 0x20, 0x69, 0x72, 0x2e, 0x6e, 0x74, 0x6e, 0x61, 0x65, 0x65,
            0x6d, 0x2e, 0x68, 0x6f, 0x74, 0x74, 0x65, 0x6e, 0x74, 0x6f, 0x74, 0x2e,
            0x72, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x2e, 0x54, 0x63, 0x70, 0x43,
            0x6c, 0x69, 0x65, 0x6e, 0x74, 0x3b, 0x0a, 0x69, 0x6d, 0x70, 0x6f, 0x72,
            0x74, 0x20, 0x69, 0x72, 0x2e, 0x6e, 0x74, 0x6e, 0x61, 0x65, 0x65, 0x6d,
            0x2e, 0x68, 0x6f, 0x74, 0x74, 0x65, 0x6e, 0x74, 0x6f, 0x74, 0x2e, 0x72,
            0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x2e, 0x65, 0x78, 0x63, 0x65, 0x70,
            0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x48, 0x6f, 0x74, 0x74, 0x65, 0x6e, 0x74,
            0x6f, 0x74, 0x52, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x45, 0x78, 0x63,
            0x65, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x3b, 0x0a, 0x69, 0x6d, 0x70, 0x6f,
            0x72, 0x74, 0x20, 0x69, 0x72, 0x2e, 0x6e, 0x74, 0x6e, 0x61, 0x65, 0x65,
            0x6d, 0x2e, 0x68, 0x6f, 0x74, 0x74, 0x65, 0x6e, 0x74, 0x6f, 0x74, 0x2e,
            0x72, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x2e, 0x65, 0x78, 0x63, 0x65,
            0x70, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x54, 0x63, 0x70, 0x43, 0x6c, 0x69,
            0x65, 0x6e, 0x74, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x45, 0x78,
            0x63, 0x65, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x3b, 0x0a, 0x69, 0x6d, 0x70,
            0x6f, 0x72, 0x74, 0x20, 0x69, 0x72, 0x2e, 0x6e, 0x74, 0x6e, 0x61, 0x65,
            0x65, 0x6d, 0x2e, 0x68, 0x6f, 0x74, 0x74, 0x65, 0x6e, 0x74, 0x6f, 0x74,
            0x2e, 0x72, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x2e, 0x65, 0x78, 0x63,
            0x65, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x54, 0x63, 0x70, 0x43, 0x6c,
            0x69, 0x65, 0x6e, 0x74, 0x52, 0x65, 0x61, 0x64, 0x45, 0x78, 0x63, 0x65,
            0x70, 0x74, 0x69, 0x6f, 0x6e, 0x3b, 0x0a, 0x69, 0x6d, 0x70, 0x6f, 0x72,
            0x74, 0x20, 0x69, 0x72, 0x2e, 0x6e, 0x74, 0x6e, 0x61, 0x65, 0x65, 0x6d,
            0x2e, 0x68, 0x6f, 0x74, 0x74, 0x65, 0x6e, 0x74, 0x6f, 0x74, 0x2e, 0x72,
            0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x2e, 0x65, 0x78, 0x63, 0x65, 0x70,
            0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x54, 0x63, 0x70, 0x43, 0x6c, 0x69, 0x65,
            0x6e, 0x74, 0x57, 0x72, 0x69, 0x74, 0x65, 0x45, 0x78, 0x63, 0x65, 0x70,
            0x74, 0x69, 0x6f, 0x6e, 0x3b, 0x0a, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74,
            0x20, 0x69, 0x72, 0x2e, 0x6e, 0x74, 0x6e, 0x61, 0x65, 0x65, 0x6d, 0x2e,
            0x68, 0x6f, 0x74, 0x74, 0x65, 0x6e, 0x74, 0x6f, 0x74, 0x2e, 0x72, 0x75,
            0x6e, 0x74, 0x69, 0x6d, 0x65, 0x2e, 0x66, 0x61, 0x63, 0x74, 0x6f, 0x72,
            0x79, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x46, 0x61,
            0x63, 0x74, 0x6f, 0x72, 0x79, 0x3b, 0x0a, 0x69, 0x6d, 0x70, 0x6f, 0x72,
            0x74, 0x20, 0x69, 0x72, 0x2e, 0x6e, 0x74, 0x6e, 0x61, 0x65, 0x65, 0x6d,
            0x2e, 0x68, 0x6f, 0x74, 0x74, 0x65, 0x6e, 0x74, 0x6f, 0x74, 0x2e, 0x72,
            0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x2e, 0x66, 0x61, 0x63, 0x74, 0x6f,
            0x72, 0x79, 0x2e, 0x54, 0x63, 0x70, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74,
            0x46, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x79, 0x3b, 0x0a, 0x69, 0x6d, 0x70,
            0x6f, 0x72, 0x74, 0x20, 0x69, 0x72, 0x2e, 0x6e, 0x74, 0x6e, 0x61, 0x65,
            0x65, 0x6d, 0x2e, 0x68, 0x6f, 0x74, 0x74, 0x65, 0x6e, 0x74, 0x6f, 0x74,
            0x2e, 0x72, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x2e, 0x70, 0x72, 0x6f,
            0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63,
            0x6f, 0x6c, 0x3b, 0x0a, 0x0a, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x20,
            0x63, 0x6c, 0x61, 0x73, 0x73, 0x20, 0x5b, 0x25, 0x53, 0x45, 0x52, 0x56,
            0x49, 0x43, 0x45, 0x5f, 0x4e, 0x41, 0x4d, 0x45, 0x25, 0x5d, 0x53, 0x65,
            0x72, 0x76, 0x69, 0x63, 0x65, 0x50, 0x72, 0x6f, 0x78, 0x79, 0x20, 0x65,
            0x78, 0x74, 0x65, 0x6e, 0x64, 0x73, 0x20, 0x41, 0x62, 0x73, 0x74, 0x72,
            0x61, 0x63, 0x74, 0x5b, 0x25, 0x53, 0x45, 0x52, 0x56, 0x49, 0x43, 0x45,
            0x5f, 0x4e, 0x41, 0x4d, 0x45, 0x25, 0x5d, 0x53, 0x65, 0x72, 0x76, 0x69,
            0x63, 0x65, 0x20, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74,
            0x73, 0x20, 0x50, 0x72, 0x6f, 0x78, 0x79, 0x20, 0x7b, 0x0a, 0x09, 0x0a,
            0x09, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 0x65, 0x20, 0x53, 0x74, 0x72,
            0x69, 0x6e, 0x67, 0x20, 0x68, 0x6f, 0x73, 0x74, 0x3b, 0x0a, 0x09, 0x70,
            0x72, 0x69, 0x76, 0x61, 0x74, 0x65, 0x20, 0x69, 0x6e, 0x74, 0x20, 0x70,
            0x6f, 0x72, 0x74, 0x3b, 0x0a, 0x0a, 0x09, 0x70, 0x75, 0x62, 0x6c, 0x69,
            0x63, 0x20, 0x5b, 0x25, 0x53, 0x45, 0x52, 0x56, 0x49, 0x43, 0x45, 0x5f,
            0x4e, 0x41, 0x4d, 0x45, 0x25, 0x5d, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63,
            0x65, 0x50, 0x72, 0x6f, 0x78, 0x79, 0x28, 0x53, 0x74, 0x72, 0x69, 0x6e,
            0x67, 0x20, 0x68, 0x6f, 0x73, 0x74, 0x2c, 0x20, 0x69, 0x6e, 0x74, 0x20,
            0x70, 0x6f, 0x72, 0x74, 0x29, 0x20, 0x7b, 0x0a, 0x09, 0x09, 0x74, 0x68,
            0x69, 0x73, 0x2e, 0x68, 0x6f, 0x73, 0x74, 0x20, 0x3d, 0x20, 0x68, 0x6f,
            0x73, 0x74, 0x3b, 0x0a, 0x09, 0x09, 0x74, 0x68, 0x69, 0x73, 0x2e, 0x70,
            0x6f, 0x72, 0x74, 0x20, 0x3d, 0x20, 0x70, 0x6f, 0x72, 0x74, 0x3b, 0x0a,
            0x09, 0x7d, 0x0a, 0x09, 0x5b, 0x25, 0x4d, 0x45, 0x54, 0x48, 0x4f, 0x44,
            0x53, 0x25, 0x5d, 0x0a, 0x09, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x20,
            0x76, 0x6f, 0x69, 0x64, 0x20, 0x64, 0x65, 0x73, 0x74, 0x72, 0x6f, 0x79,
            0x28, 0x29, 0x20, 0x7b, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
            0x20, 0x09, 0x2f, 0x2f, 0x54, 0x4f, 0x44, 0x4f, 0x0a, 0x09, 0x7d, 0x0a,
            0x7d, 0x0a
    		};
			uint32_t serviceProxyByteArrayLength = 1034;

    		unsigned char absractServiceByteArray[] = {
			  0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x20, 0x5b, 0x25, 0x42, 0x41,
			  0x53, 0x45, 0x5f, 0x50, 0x41, 0x43, 0x4b, 0x41, 0x47, 0x45, 0x5f, 0x4e,
			  0x41, 0x4d, 0x45, 0x25, 0x5d, 0x3b, 0x0a, 0x0a, 0x69, 0x6d, 0x70, 0x6f,
			  0x72, 0x74, 0x20, 0x69, 0x72, 0x2e, 0x6e, 0x74, 0x6e, 0x61, 0x65, 0x65,
			  0x6d, 0x2e, 0x68, 0x6f, 0x74, 0x74, 0x65, 0x6e, 0x74, 0x6f, 0x74, 0x2e,
			  0x72, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x2e, 0x52, 0x65, 0x71, 0x75,
			  0x65, 0x73, 0x74, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x3b, 0x0a,
			  0x0a, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x20, 0x61, 0x62, 0x73, 0x74,
			  0x72, 0x61, 0x63, 0x74, 0x20, 0x63, 0x6c, 0x61, 0x73, 0x73, 0x20, 0x41,
			  0x62, 0x73, 0x74, 0x72, 0x61, 0x63, 0x74, 0x5b, 0x25, 0x53, 0x45, 0x52,
			  0x56, 0x49, 0x43, 0x45, 0x5f, 0x4e, 0x41, 0x4d, 0x45, 0x25, 0x5d, 0x53,
			  0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20, 0x69, 0x6d, 0x70, 0x6c, 0x65,
			  0x6d, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x5b, 0x25, 0x53, 0x45, 0x52, 0x56,
			  0x49, 0x43, 0x45, 0x5f, 0x4e, 0x41, 0x4d, 0x45, 0x25, 0x5d, 0x53, 0x65,
			  0x72, 0x76, 0x69, 0x63, 0x65, 0x20, 0x7b, 0x09, 0x0a, 0x09, 0x70, 0x75,
			  0x62, 0x6c, 0x69, 0x63, 0x20, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
			  0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x20, 0x6d, 0x61, 0x6b, 0x65,
			  0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x48, 0x61, 0x6e, 0x64, 0x6c,
			  0x65, 0x72, 0x28, 0x29, 0x20, 0x7b, 0x0a, 0x09, 0x09, 0x72, 0x65, 0x74,
			  0x75, 0x72, 0x6e, 0x20, 0x6e, 0x65, 0x77, 0x20, 0x5b, 0x25, 0x53, 0x45,
			  0x52, 0x56, 0x49, 0x43, 0x45, 0x5f, 0x4e, 0x41, 0x4d, 0x45, 0x25, 0x5d,
			  0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x48, 0x61, 0x6e, 0x64, 0x6c,
			  0x65, 0x72, 0x28, 0x74, 0x68, 0x69, 0x73, 0x29, 0x3b, 0x0a, 0x09, 0x7d,
			  0x0a, 0x09, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x20, 0x69, 0x6e, 0x74,
			  0x20, 0x67, 0x65, 0x74, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x49,
			  0x64, 0x28, 0x29, 0x20, 0x7b, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
			  0x20, 0x20, 0x09, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x5b, 0x25,
			  0x53, 0x45, 0x52, 0x56, 0x49, 0x43, 0x45, 0x5f, 0x49, 0x44, 0x25, 0x5d,
			  0x3b, 0x0a, 0x09, 0x7d, 0x0a, 0x7d, 0x0a
			};
			uint32_t absractServiceByteArrayLength = 343;

			unsigned char requestHandlerByteArray[] = {
			  0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x20, 0x5b, 0x25, 0x42, 0x41,
			  0x53, 0x45, 0x5f, 0x50, 0x41, 0x43, 0x4b, 0x41, 0x47, 0x45, 0x5f, 0x4e,
			  0x41, 0x4d, 0x45, 0x25, 0x5d, 0x3b, 0x0a, 0x0a, 0x69, 0x6d, 0x70, 0x6f,
			  0x72, 0x74, 0x20, 0x69, 0x72, 0x2e, 0x6e, 0x74, 0x6e, 0x61, 0x65, 0x65,
			  0x6d, 0x2e, 0x68, 0x6f, 0x74, 0x74, 0x65, 0x6e, 0x74, 0x6f, 0x74, 0x2e,
			  0x72, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x2e, 0x41, 0x72, 0x67, 0x75,
			  0x6d, 0x65, 0x6e, 0x74, 0x3b, 0x0a, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74,
			  0x20, 0x69, 0x72, 0x2e, 0x6e, 0x74, 0x6e, 0x61, 0x65, 0x65, 0x6d, 0x2e,
			  0x68, 0x6f, 0x74, 0x74, 0x65, 0x6e, 0x74, 0x6f, 0x74, 0x2e, 0x72, 0x75,
			  0x6e, 0x74, 0x69, 0x6d, 0x65, 0x2e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
			  0x74, 0x3b, 0x0a, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x20, 0x69, 0x72,
			  0x2e, 0x6e, 0x74, 0x6e, 0x61, 0x65, 0x65, 0x6d, 0x2e, 0x68, 0x6f, 0x74,
			  0x74, 0x65, 0x6e, 0x74, 0x6f, 0x74, 0x2e, 0x72, 0x75, 0x6e, 0x74, 0x69,
			  0x6d, 0x65, 0x2e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x48, 0x61,
			  0x6e, 0x64, 0x6c, 0x65, 0x72, 0x3b, 0x0a, 0x69, 0x6d, 0x70, 0x6f, 0x72,
			  0x74, 0x20, 0x69, 0x72, 0x2e, 0x6e, 0x74, 0x6e, 0x61, 0x65, 0x65, 0x6d,
			  0x2e, 0x68, 0x6f, 0x74, 0x74, 0x65, 0x6e, 0x74, 0x6f, 0x74, 0x2e, 0x72,
			  0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x2e, 0x52, 0x65, 0x73, 0x70, 0x6f,
			  0x6e, 0x73, 0x65, 0x3b, 0x0a, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x20,
			  0x69, 0x72, 0x2e, 0x6e, 0x74, 0x6e, 0x61, 0x65, 0x65, 0x6d, 0x2e, 0x68,
			  0x6f, 0x74, 0x74, 0x65, 0x6e, 0x74, 0x6f, 0x74, 0x2e, 0x72, 0x75, 0x6e,
			  0x74, 0x69, 0x6d, 0x65, 0x2e, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
			  0x3b, 0x0a, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x20, 0x69, 0x72, 0x2e,
			  0x6e, 0x74, 0x6e, 0x61, 0x65, 0x65, 0x6d, 0x2e, 0x68, 0x6f, 0x74, 0x74,
			  0x65, 0x6e, 0x74, 0x6f, 0x74, 0x2e, 0x72, 0x75, 0x6e, 0x74, 0x69, 0x6d,
			  0x65, 0x2e, 0x65, 0x78, 0x63, 0x65, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x2e,
			  0x4d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x4e, 0x6f, 0x74, 0x53, 0x75, 0x70,
			  0x70, 0x6f, 0x72, 0x74, 0x45, 0x78, 0x63, 0x65, 0x70, 0x74, 0x69, 0x6f,
			  0x6e, 0x3b, 0x0a, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x20, 0x69, 0x72,
			  0x2e, 0x6e, 0x74, 0x6e, 0x61, 0x65, 0x65, 0x6d, 0x2e, 0x68, 0x6f, 0x74,
			  0x74, 0x65, 0x6e, 0x74, 0x6f, 0x74, 0x2e, 0x72, 0x75, 0x6e, 0x74, 0x69,
			  0x6d, 0x65, 0x2e, 0x65, 0x78, 0x63, 0x65, 0x70, 0x74, 0x69, 0x6f, 0x6e,
			  0x2e, 0x54, 0x63, 0x70, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x43, 0x6f,
			  0x6e, 0x6e, 0x65, 0x63, 0x74, 0x45, 0x78, 0x63, 0x65, 0x70, 0x74, 0x69,
			  0x6f, 0x6e, 0x3b, 0x0a, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x20, 0x69,
			  0x72, 0x2e, 0x6e, 0x74, 0x6e, 0x61, 0x65, 0x65, 0x6d, 0x2e, 0x68, 0x6f,
			  0x74, 0x74, 0x65, 0x6e, 0x74, 0x6f, 0x74, 0x2e, 0x72, 0x75, 0x6e, 0x74,
			  0x69, 0x6d, 0x65, 0x2e, 0x65, 0x78, 0x63, 0x65, 0x70, 0x74, 0x69, 0x6f,
			  0x6e, 0x2e, 0x54, 0x63, 0x70, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x52,
			  0x65, 0x61, 0x64, 0x45, 0x78, 0x63, 0x65, 0x70, 0x74, 0x69, 0x6f, 0x6e,
			  0x3b, 0x0a, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x20, 0x69, 0x72, 0x2e,
			  0x6e, 0x74, 0x6e, 0x61, 0x65, 0x65, 0x6d, 0x2e, 0x68, 0x6f, 0x74, 0x74,
			  0x65, 0x6e, 0x74, 0x6f, 0x74, 0x2e, 0x72, 0x75, 0x6e, 0x74, 0x69, 0x6d,
			  0x65, 0x2e, 0x65, 0x78, 0x63, 0x65, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x2e,
			  0x54, 0x63, 0x70, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x57, 0x72, 0x69,
			  0x74, 0x65, 0x45, 0x78, 0x63, 0x65, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x3b,
			  0x0a, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x20, 0x6a, 0x61, 0x76, 0x61,
			  0x2e, 0x75, 0x74, 0x69, 0x6c, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x3b, 0x0a,
			  0x0a, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x20, 0x63, 0x6c, 0x61, 0x73,
			  0x73, 0x20, 0x5b, 0x25, 0x53, 0x45, 0x52, 0x56, 0x49, 0x43, 0x45, 0x5f,
			  0x4e, 0x41, 0x4d, 0x45, 0x25, 0x5d, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
			  0x74, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x20, 0x65, 0x78, 0x74,
			  0x65, 0x6e, 0x64, 0x73, 0x20, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
			  0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x20, 0x7b, 0x0a, 0x20, 0x20,
			  0x20, 0x20, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x20, 0x5b, 0x25, 0x53,
			  0x45, 0x52, 0x56, 0x49, 0x43, 0x45, 0x5f, 0x4e, 0x41, 0x4d, 0x45, 0x25,
			  0x5d, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x48, 0x61, 0x6e, 0x64,
			  0x6c, 0x65, 0x72, 0x28, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20,
			  0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x29, 0x20, 0x7b, 0x0a, 0x20,
			  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x73, 0x75, 0x70, 0x65, 0x72,
			  0x28, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x29, 0x3b, 0x0a, 0x20,
			  0x20, 0x20, 0x20, 0x7d, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x40, 0x4f, 0x76,
			  0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x70,
			  0x75, 0x62, 0x6c, 0x69, 0x63, 0x20, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
			  0x73, 0x65, 0x20, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x52, 0x65, 0x71,
			  0x75, 0x65, 0x73, 0x74, 0x28, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
			  0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x29, 0x20, 0x74, 0x68,
			  0x72, 0x6f, 0x77, 0x73, 0x20, 0x54, 0x63, 0x70, 0x43, 0x6c, 0x69, 0x65,
			  0x6e, 0x74, 0x57, 0x72, 0x69, 0x74, 0x65, 0x45, 0x78, 0x63, 0x65, 0x70,
			  0x74, 0x69, 0x6f, 0x6e, 0x2c, 0x20, 0x54, 0x63, 0x70, 0x43, 0x6c, 0x69,
			  0x65, 0x6e, 0x74, 0x52, 0x65, 0x61, 0x64, 0x45, 0x78, 0x63, 0x65, 0x70,
			  0x74, 0x69, 0x6f, 0x6e, 0x2c, 0x20, 0x54, 0x63, 0x70, 0x43, 0x6c, 0x69,
			  0x65, 0x6e, 0x74, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x45, 0x78,
			  0x63, 0x65, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x2c, 0x20, 0x4d, 0x65, 0x74,
			  0x68, 0x6f, 0x64, 0x4e, 0x6f, 0x74, 0x53, 0x75, 0x70, 0x70, 0x6f, 0x72,
			  0x74, 0x45, 0x78, 0x63, 0x65, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x7b,
			  0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x62, 0x79, 0x74,
			  0x65, 0x20, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x49, 0x64, 0x20, 0x3d,
			  0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x2e, 0x67, 0x65, 0x74,
			  0x4d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x49, 0x64, 0x28, 0x29, 0x3b, 0x0a,
			  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5b, 0x25, 0x53, 0x45,
			  0x52, 0x56, 0x49, 0x43, 0x45, 0x5f, 0x4e, 0x41, 0x4d, 0x45, 0x25, 0x5d,
			  0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20, 0x5b, 0x25, 0x53, 0x45,
			  0x52, 0x56, 0x49, 0x43, 0x45, 0x5f, 0x4e, 0x41, 0x4d, 0x45, 0x5f, 0x4c,
			  0x4f, 0x57, 0x45, 0x52, 0x43, 0x41, 0x53, 0x45, 0x25, 0x5d, 0x49, 0x6d,
			  0x70, 0x6c, 0x20, 0x3d, 0x20, 0x28, 0x41, 0x62, 0x73, 0x74, 0x72, 0x61,
			  0x63, 0x74, 0x5b, 0x25, 0x53, 0x45, 0x52, 0x56, 0x49, 0x43, 0x45, 0x5f,
			  0x4e, 0x41, 0x4d, 0x45, 0x25, 0x5d, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63,
			  0x65, 0x29, 0x20, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x3b, 0x0a,
			  0x0a, 0x09, 0x5b, 0x25, 0x4d, 0x45, 0x54, 0x48, 0x4f, 0x44, 0x5f, 0x43,
			  0x4f, 0x4e, 0x44, 0x49, 0x54, 0x49, 0x4f, 0x4e, 0x53, 0x25, 0x5d, 0x0a,
			  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x74, 0x68, 0x72, 0x6f,
			  0x77, 0x20, 0x6e, 0x65, 0x77, 0x20, 0x4d, 0x65, 0x74, 0x68, 0x6f, 0x64,
			  0x4e, 0x6f, 0x74, 0x53, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x45, 0x78,
			  0x63, 0x65, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x28, 0x22, 0x6d, 0x65, 0x74,
			  0x68, 0x6f, 0x64, 0x20, 0x69, 0x64, 0x20, 0x69, 0x73, 0x20, 0x69, 0x6e,
			  0x63, 0x6f, 0x72, 0x72, 0x65, 0x63, 0x74, 0x22, 0x29, 0x3b, 0x0a, 0x20,
			  0x20, 0x20, 0x20, 0x7d, 0x0a, 0x7d, 0x0a
			};
			uint32_t requestHandlerByteArrayLength = 1171;

			unsigned char serviceByteArray[] = {
			  0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x20, 0x5b, 0x25, 0x42, 0x41,
			  0x53, 0x45, 0x5f, 0x50, 0x41, 0x43, 0x4b, 0x41, 0x47, 0x45, 0x5f, 0x4e,
			  0x41, 0x4d, 0x45, 0x25, 0x5d, 0x3b, 0x0a, 0x0a, 0x69, 0x6d, 0x70, 0x6f,
			  0x72, 0x74, 0x20, 0x69, 0x72, 0x2e, 0x6e, 0x74, 0x6e, 0x61, 0x65, 0x65,
			  0x6d, 0x2e, 0x68, 0x6f, 0x74, 0x74, 0x65, 0x6e, 0x74, 0x6f, 0x74, 0x2e,
			  0x72, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x2e, 0x53, 0x65, 0x72, 0x76,
			  0x69, 0x63, 0x65, 0x3b, 0x0a, 0x0a, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63,
			  0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x20, 0x5b,
			  0x25, 0x53, 0x45, 0x52, 0x56, 0x49, 0x43, 0x45, 0x5f, 0x4e, 0x41, 0x4d,
			  0x45, 0x25, 0x5d, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20, 0x65,
			  0x78, 0x74, 0x65, 0x6e, 0x64, 0x73, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69,
			  0x63, 0x65, 0x20, 0x7b, 0x0a, 0x5b, 0x25, 0x53, 0x45, 0x52, 0x56, 0x49,
			  0x43, 0x45, 0x5f, 0x4d, 0x45, 0x54, 0x48, 0x4f, 0x44, 0x53, 0x25, 0x5d,
			  0x0a, 0x7d, 0x0a
			};
			uint32_t serviceByteArrayLength = 159;

			unsigned char serviceProxyBuilderByteArray[] = {
			  0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x20, 0x5b, 0x25, 0x42, 0x41,
			  0x53, 0x45, 0x5f, 0x50, 0x41, 0x43, 0x4b, 0x41, 0x47, 0x45, 0x5f, 0x4e,
			  0x41, 0x4d, 0x45, 0x25, 0x5d, 0x3b, 0x0a, 0x0a, 0x70, 0x75, 0x62, 0x6c,
			  0x69, 0x63, 0x20, 0x63, 0x6c, 0x61, 0x73, 0x73, 0x20, 0x5b, 0x25, 0x53,
			  0x45, 0x52, 0x56, 0x49, 0x43, 0x45, 0x5f, 0x4e, 0x41, 0x4d, 0x45, 0x25,
			  0x5d, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x50, 0x72, 0x6f, 0x78,
			  0x79, 0x42, 0x75, 0x69, 0x6c, 0x64, 0x65, 0x72, 0x20, 0x7b, 0x0a, 0x0a,
			  0x09, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x20, 0x73, 0x74, 0x61, 0x74,
			  0x69, 0x63, 0x20, 0x5b, 0x25, 0x53, 0x45, 0x52, 0x56, 0x49, 0x43, 0x45,
			  0x5f, 0x4e, 0x41, 0x4d, 0x45, 0x25, 0x5d, 0x53, 0x65, 0x72, 0x76, 0x69,
			  0x63, 0x65, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x28, 0x53, 0x74,
			  0x72, 0x69, 0x6e, 0x67, 0x20, 0x68, 0x6f, 0x73, 0x74, 0x2c, 0x20, 0x69,
			  0x6e, 0x74, 0x20, 0x70, 0x6f, 0x72, 0x74, 0x29, 0x20, 0x7b, 0x0a, 0x09,
			  0x09, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x6e, 0x65, 0x77, 0x20,
			  0x5b, 0x25, 0x53, 0x45, 0x52, 0x56, 0x49, 0x43, 0x45, 0x5f, 0x4e, 0x41,
			  0x4d, 0x45, 0x25, 0x5d, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x50,
			  0x72, 0x6f, 0x78, 0x79, 0x28, 0x68, 0x6f, 0x73, 0x74, 0x2c, 0x70, 0x6f,
			  0x72, 0x74, 0x29, 0x3b, 0x0a, 0x09, 0x7d, 0x0a, 0x0a, 0x20, 0x20, 0x20,
			  0x20, 0x09, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x20, 0x73, 0x74, 0x61,
			  0x74, 0x69, 0x63, 0x20, 0x76, 0x6f, 0x69, 0x64, 0x20, 0x64, 0x65, 0x73,
			  0x74, 0x72, 0x6f, 0x79, 0x28, 0x29, 0x20, 0x7b, 0x0a, 0x20, 0x20, 0x20,
			  0x20, 0x20, 0x20, 0x20, 0x20, 0x09, 0x2f, 0x2f, 0x54, 0x4f, 0x44, 0x4f,
			  0x0a, 0x20, 0x20, 0x20, 0x20, 0x09, 0x7d, 0x0a, 0x7d, 0x0a
			};
			uint32_t serviceProxyBuilderByteArrayLength = 274;

			unsigned char structByteArray[] = {
			  0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x20, 0x5b, 0x25, 0x42, 0x41,
			  0x53, 0x45, 0x5f, 0x50, 0x41, 0x43, 0x4b, 0x41, 0x47, 0x45, 0x5f, 0x4e,
			  0x41, 0x4d, 0x45, 0x25, 0x5d, 0x3b, 0x0a, 0x0a, 0x70, 0x75, 0x62, 0x6c,
			  0x69, 0x63, 0x20, 0x63, 0x6c, 0x61, 0x73, 0x73, 0x20, 0x5b, 0x25, 0x53,
			  0x54, 0x52, 0x55, 0x43, 0x54, 0x5f, 0x4e, 0x41, 0x4d, 0x45, 0x25, 0x5d,
			  0x20, 0x7b, 0x0a, 0x5b, 0x25, 0x4d, 0x45, 0x4d, 0x42, 0x45, 0x52, 0x53,
			  0x25, 0x5d, 0x09, 0x0a, 0x09, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x20,
			  0x62, 0x79, 0x74, 0x65, 0x5b, 0x5d, 0x20, 0x73, 0x65, 0x72, 0x69, 0x61,
			  0x6c, 0x69, 0x7a, 0x65, 0x28, 0x29, 0x20, 0x7b, 0x0a, 0x09, 0x09, 0x2f,
			  0x2f, 0x54, 0x4f, 0x44, 0x4f, 0x28, 0x61, 0x6c, 0x69, 0x29, 0x0a, 0x09,
			  0x09, 0x2f, 0x2f, 0x66, 0x61, 0x6b, 0x65, 0x20, 0x69, 0x6d, 0x70, 0x6c,
			  0x65, 0x6d, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x0a, 0x09,
			  0x09, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x6e, 0x65, 0x77, 0x20,
			  0x62, 0x79, 0x74, 0x65, 0x5b, 0x5d, 0x7b, 0x20, 0x39, 0x37, 0x20, 0x7d,
			  0x3b, 0x0a, 0x09, 0x7d, 0x0a, 0x09, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63,
			  0x20, 0x76, 0x6f, 0x69, 0x64, 0x20, 0x64, 0x65, 0x73, 0x65, 0x72, 0x69,
			  0x61, 0x6c, 0x69, 0x7a, 0x65, 0x28, 0x62, 0x79, 0x74, 0x65, 0x5b, 0x5d,
			  0x20, 0x73, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x69, 0x7a, 0x65, 0x64, 0x54,
			  0x6f, 0x6b, 0x65, 0x6e, 0x29, 0x20, 0x7b, 0x0a, 0x09, 0x09, 0x2f, 0x2f,
			  0x54, 0x4f, 0x44, 0x4f, 0x28, 0x61, 0x6c, 0x69, 0x29, 0x0a, 0x09, 0x09,
			  0x2f, 0x2f, 0x66, 0x61, 0x6b, 0x65, 0x20, 0x69, 0x6d, 0x70, 0x6c, 0x65,
			  0x6d, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x0a, 0x09, 0x09,
			  0x73, 0x65, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x28, 0x22, 0x74, 0x65,
			  0x73, 0x74, 0x2d, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x22, 0x29, 0x3b, 0x0a,
			  0x09, 0x7d, 0x0a, 0x7d, 0x0a
			};
			uint32_t structByteArrayLength = 293;
			//
    		std::string serviceProxyTmpStr( reinterpret_cast<char const*>(serviceProxyByteArray), serviceProxyByteArrayLength);
    		serviceProxyTmpStr_ = serviceProxyTmpStr;

    		std::string abstractServiceTmpStr( reinterpret_cast<char const*>(absractServiceByteArray), absractServiceByteArrayLength);
    		abstractServiceTmpStr_ = abstractServiceTmpStr;

    		std::string requestHandlerTmpStr( reinterpret_cast<char const*>(requestHandlerByteArray), requestHandlerByteArrayLength);
    		requestHandlerTmpStr_ = requestHandlerTmpStr;

    		std::string serviceTmpStr( reinterpret_cast<char const*>(serviceByteArray), serviceByteArrayLength);
    		serviceTmpStr_ = serviceTmpStr;

    		std::string serviceProxyBuilderTmpStr( reinterpret_cast<char const*>(serviceProxyBuilderByteArray), serviceProxyBuilderByteArrayLength);
    		serviceProxyBuilderTmpStr_ = serviceProxyBuilderTmpStr;

    		std::string structTmpStr( reinterpret_cast<char const*>(structByteArray), structByteArrayLength);
    		structTmpStr_ = structTmpStr;
		}
		void
		JavaGenerator::ReadTemplateFiles() {
		    //using the ds to write .hot file

			    //TODO use buffer reading
//			    char buffer[100];
//			    FILE* f = fopen("/home/developer/Desktop/templates/struct.tmp","rb");
//				std::string str;
//			    while(true){
//			        unsigned int r = fread(buffer , sizeof(char), 10 ,f);
//			        str += reinterpret_cast< char const* >(buffer);
//			        if(r == 0){
//			            break;
//			        }
//			    }
//
//			    fclose(f);
//			    f = fopen("/home/developer/Desktop/templates/new.tmp","wb");
//			    fwrite(str.c_str() , sizeof(char), str.length(),f);
//			    fclose(f);

		    is.open("/home/developer/projects/hottentot-git/generator/java/templates/struct.tmp", std::ios::in);
		    //TODO use buffer reader
		    char c;
		    while ((c = is.get()) != -1) {
		        structTmpStr_ += c;
		    }
		    is.close();
		    is.open("/home/developer/projects/hottentot-git/generator/java/templates/abstractService.tmp", std::ios::in);
		    //TODO use buffer reader
		    while ((c = is.get()) != -1) {
		        abstractServiceTmpStr_ += c;
		    }
		    is.close();

		    //service interface
		    is.open("/home/developer/projects/hottentot-git/generator/java/templates/service.tmp", std::ios::in);
		    //TODO use buffer reader
		    while ((c = is.get()) != -1) {
		        serviceTmpStr_ += c;
		    }
		    is.close();
		    //service proxy
		    is.open("/home/developer/projects/hottentot-git/generator/java/templates/serviceProxy.tmp",
		            std::ios::in);
		    while ((c = is.get()) != -1) {
		        serviceProxyTmpStr_ += c;
		    }
		    is.close();
			
		    //service proxy builder
		    is.open("/home/developer/projects/hottentot-git/generator/java/templates/serviceProxyBuilder.tmp",
		            std::ios::in);
		    //TODO use buffer reader
		    while ((c = is.get()) != -1) {
		        serviceProxyBuilderTmpStr_ += c;
		    }
		    is.close();

		    //request handler
		    is.open("/home/developer/projects/hottentot-git/generator/java/templates/requestHandler.tmp",
		            std::ios::in);
		    //TODO use buffer reader
		    while ((c = is.get()) != -1) {
		        requestHandlerTmpStr_ += c;
		    }
		    is.close();
//			std::cout << "---------------" << std::endl;
//			std::cout << structTmpStr_;
//			std::cout << abstractServiceTmpStr_;
//			std::cout << serviceTmpStr_;
//			std::cout << serviceProxyBuilderTmpStr_;
//			std::cout << serviceProxyTmpStr_;
//			std::cout << requestHandlerTmpStr_;
		}

		void
		JavaGenerator::GenerateStructs(::naeem::hottentot::generator::ds::Module *pModule) {
		    //loop on structs in everey module
		    //cout << structTmpStr << endl << "-----" << endl;
		     for (int i = 0; i < pModule->structs_.size(); i++) {
		         ::naeem::hottentot::generator::ds::Struct *pStruct = pModule->structs_.at(i);
				 std::string path = outDir_ + "/" +  pStruct->name_.c_str() + ".java";
		         os.open(path.c_str()  , std::ios::trunc);
		         std::string basePackageName = pModule->package_;
		         std::string replacableStructTmpStr = structTmpStr_;
		         while(replacableStructTmpStr.find("[%BASE_PACKAGE_NAME%]") != std::string::npos){
		         	replacableStructTmpStr.replace(replacableStructTmpStr.find("[%BASE_PACKAGE_NAME%]"), 21, basePackageName);	
		         }
		         while(replacableStructTmpStr.find("[%STRUCT_NAME%]") != std::string::npos){
		         	replacableStructTmpStr.replace(replacableStructTmpStr.find("[%STRUCT_NAME%]"), 15 , pStruct->name_);	
		         }
		         std::string declarationStr;
		         std::string getterSetterStr;
		         
		         for (int i = 0; i < pStruct->declarations_.size(); i++) {
		         	//TODO change string to string
		             ::naeem::hottentot::generator::ds::Declaration *declarationPtr = pStruct->declarations_.at(i);
		             if (declarationPtr->type_.compare("string") == 0){
		             	declarationPtr->type_[0] = 'S';
		             }
		             std::string declarationName = declarationPtr->variable_;
		             std::string capitalizedDeclarationName = declarationPtr->variable_;
		             capitalizedDeclarationName[0] -= 32;
		             declarationStr += "\tprivate " + declarationPtr->type_ + " " + declarationName + ";\n";
		             getterSetterStr += "\tpublic void set" + capitalizedDeclarationName + "(" + declarationPtr->type_ + " " + declarationName + ") {\n";
		             getterSetterStr += "\t\tthis." + declarationName + " = " + declarationName + ";\n";
		             getterSetterStr += "\t}\n";
		             getterSetterStr += "\tpublic " + declarationPtr->type_ + " get" + capitalizedDeclarationName + "() {\n";
		             getterSetterStr += "\t\treturn " + declarationPtr->variable_ + ";\n";
		             getterSetterStr += "\t}\n";
		         }
		         replacableStructTmpStr.replace(replacableStructTmpStr.find("[%MEMBERS%]"), 11,
		                                        declarationStr + getterSetterStr);
		         os.write(replacableStructTmpStr.c_str(), replacableStructTmpStr.size());
		         os.close();
		     }
		}

		void
		JavaGenerator::GenerateAbstractService(::naeem::hottentot::generator::ds::Module *pModule) {
		    //loop for every services
		    ::naeem::hottentot::generator::ds::Service *pService;
		    std::string replacableAbstractServiceTmpStr;
		    for (int i = 0; i < pModule->services_.size(); i++) {
		        //write abstractService.tmp
		        std::string basePackageName = pModule->package_;
		        pService = pModule->services_.at(i);
		        std::string path = outDir_ + "/Abstract" + pService->name_.c_str() + "Service.java";
		        os.open(path.c_str() , std::ios::trunc);
		        replacableAbstractServiceTmpStr = abstractServiceTmpStr_;


		        while(replacableAbstractServiceTmpStr.find("[%BASE_PACKAGE_NAME%]") != std::string::npos){
		         	replacableAbstractServiceTmpStr.replace(replacableAbstractServiceTmpStr.find("[%BASE_PACKAGE_NAME%]"), 21, basePackageName);	
		        }
		        while(replacableAbstractServiceTmpStr.find("[%SERVICE_NAME%]") != std::string::npos){
		         	replacableAbstractServiceTmpStr.replace(replacableAbstractServiceTmpStr.find("[%SERVICE_NAME%]"), 16 , pService->name_);	
		        }
		        std::stringstream ssID;
		        //TODO get service ID from hot parser
		        //ssID << pService->id_;
		        ssID << "1";
		        replacableAbstractServiceTmpStr.replace(replacableAbstractServiceTmpStr.find("[%SERVICE_ID%]"), 14, ssID.str());
		        os.write(replacableAbstractServiceTmpStr.c_str(), replacableAbstractServiceTmpStr.size());
		        os.close();
		   }
		}

		void
		JavaGenerator::GenerateServiceInterface(::naeem::hottentot::generator::ds::Module *pModule) {
		    ::naeem::hottentot::generator::ds::Service *pService;
		    std::string replacableServiceTmpStr;
		    for (int i = 0; i < pModule->services_.size(); i++) {
		        //write abstractService.tmp
		        std::string basePackageName = pModule->package_;
		        pService = pModule->services_.at(i);
		        //write service interface
		        std::string replacableServiceTmpStr = serviceTmpStr_;
		        //std::cout << outDir_;
		        std::string path = outDir_ + "/" + pService->name_.c_str() + "Service.java";
		        os.open( path.c_str(), std::ios::trunc);
		        while(replacableServiceTmpStr.find("[%BASE_PACKAGE_NAME%]") != std::string::npos){
		         	replacableServiceTmpStr.replace(replacableServiceTmpStr.find("[%BASE_PACKAGE_NAME%]"), 21, basePackageName);	
		        }
		        while(replacableServiceTmpStr.find("[%SERVICE_NAME%]") != std::string::npos){
		         	replacableServiceTmpStr.replace(replacableServiceTmpStr.find("[%SERVICE_NAME%]"), 16 , pService->name_);	
		        }
		        std::string serviceMethodsStr;
		        //loop for service methods
		        ::naeem::hottentot::generator::ds::Method *pMethod;
		        for (int i = 0; i < pService->methods_.size(); i++) {
		            pMethod = pService->methods_.at(i);
		            serviceMethodsStr += "\t" + pMethod->returnType_ + " " + pMethod->name_ + "(";
		            //loop on methods arguments
		            ::naeem::hottentot::generator::ds::Argument *pArg;
		            for (int i = 0; i < pMethod->arguments_.size(); i++) {
		                pArg = pMethod->arguments_.at(i);
		                serviceMethodsStr +=  pArg->type_ + " " + pArg->variable_;
		                if (i < pMethod->arguments_.size() - 1) {
		                    serviceMethodsStr += ",";
		                }
		            }
		            serviceMethodsStr += ");";
		        };
		        replacableServiceTmpStr.replace(replacableServiceTmpStr.find("[%SERVICE_METHODS%]"), 19, serviceMethodsStr);
		        os.write(replacableServiceTmpStr.c_str(), replacableServiceTmpStr.size());
		        os.close();

		    }
		 }

		void
		JavaGenerator::GenerateServiceProxyBuilder(::naeem::hottentot::generator::ds::Module *pModule) {
		    ::naeem::hottentot::generator::ds::Service *pService;
		    std::string replacableServiceProxyBuilderTmpStr;
		    for (int i = 0; i < pModule->services_.size(); i++) {
		        //write abstractService.tmp
		        std::string basePackageName = pModule->package_;
		        pService = pModule->services_.at(i);
		        std::string replacableServiceProxyBuilderTmpStr;
		        //write service proxy builder
		        std::string path = outDir_ + "/" +  pService->name_.c_str() + "ServiceProxyBuilder.java";
		        os.open(path.c_str() , std::ios::trunc);
		        replacableServiceProxyBuilderTmpStr = serviceProxyBuilderTmpStr_;
		        while(replacableServiceProxyBuilderTmpStr.find("[%BASE_PACKAGE_NAME%]") != std::string::npos){
		         	replacableServiceProxyBuilderTmpStr.replace(replacableServiceProxyBuilderTmpStr.find("[%BASE_PACKAGE_NAME%]"), 21, basePackageName);	
		        }
		        while(replacableServiceProxyBuilderTmpStr.find("[%SERVICE_NAME%]") != std::string::npos){
		         	replacableServiceProxyBuilderTmpStr.replace(replacableServiceProxyBuilderTmpStr.find("[%SERVICE_NAME%]"), 16 , pService->name_);	
		        }
		        os.write(replacableServiceProxyBuilderTmpStr.c_str(), replacableServiceProxyBuilderTmpStr.size());
		        os.close();
		    }
    	}

		void
		JavaGenerator::GenerateRequestHandler(::naeem::hottentot::generator::ds::Module *pModule) {
		    ::naeem::hottentot::generator::ds::Service *pService;
		    std::string replacableRequestHandlerTmpStr;
		    std::string basePackageName = pModule->package_;
		    for (int i = 0; i < pModule->services_.size(); i++) {
		        std::string basePackageName = pModule->package_;
		        pService = pModule->services_.at(i);
		        std::string path = outDir_ + "/" +  pService->name_.c_str() + "RequestHandler.java";
		        os.open(path.c_str());
		        std::string serviceName = pService->name_;
		        std::string lowerCaseServiceName = pService->name_;
		        lowerCaseServiceName[0] += 32;
		        replacableRequestHandlerTmpStr = requestHandlerTmpStr_;
		       

		        while(replacableRequestHandlerTmpStr.find("[%BASE_PACKAGE_NAME%]") != std::string::npos){
		         	replacableRequestHandlerTmpStr.replace(replacableRequestHandlerTmpStr.find("[%BASE_PACKAGE_NAME%]"), 21, basePackageName);	
		        }
		        while(replacableRequestHandlerTmpStr.find("[%SERVICE_NAME%]") != std::string::npos){
		         	replacableRequestHandlerTmpStr.replace(replacableRequestHandlerTmpStr.find("[%SERVICE_NAME%]"), 16 , pService->name_);	
		        }
		        replacableRequestHandlerTmpStr.replace(replacableRequestHandlerTmpStr.find("[%SERVICE_NAME_LOWERCASE%]"), 26,
		                                               lowerCaseServiceName);

		        ::naeem::hottentot::generator::ds::Method *pMethod;
		        std::string methodConditionStr;

		        for (int i = 0; i < pService->methods_.size(); i++) {
		            pMethod = pService->methods_.at(i);
		            std::string lowerCaseReturnType = pMethod->returnType_;
		            lowerCaseReturnType[0] += 32;
		            std::stringstream ssID;
		            //TODO(alisharifi) make method id by hashing
		            //ssID << pMethod->id_;
		            ssID << 1;
		            methodConditionStr += "if(methodId == " + ssID.str() + "){\n";
		            methodConditionStr += "\t\tList <Argument> args = request.getArgs();\n";
		            ::naeem::hottentot::generator::ds::Argument *pArg;
		            for (int i = 0; i < pMethod->arguments_.size(); i++) {
		                pArg = pMethod->arguments_.at(i);
		                std::stringstream ssI;
		                ssI << i;
		                methodConditionStr += "\t\tArgument arg" + ssI.str() + " = args.get(" + ssI.str() + ");\n";
		                methodConditionStr += "\t\tbyte[] serialized" + pArg->type_;
		                methodConditionStr += " = arg" + ssI.str() + ".getData();\n";
		                methodConditionStr += "\t\t" + pArg->type_ + " " + pArg->variable_ + " = new " + pArg->type_ + "();\n";
		                methodConditionStr += "\t\t" + pArg->variable_ + ".deserialize(serialized" + pArg->type_ + ");\n";
		            }
		            methodConditionStr += "\t\t" + pMethod->returnType_ + " " + lowerCaseReturnType + " = null;\n";
		            methodConditionStr += "\t\tResponse response = new Response();\n";
		            //methodConditionStr += "\t\ttry{\n";
		            methodConditionStr +=
		                    "\t\t" + lowerCaseReturnType + " = " + lowerCaseServiceName + "Impl." + pMethod->name_ + "(";
		            for (int i = 0; i < pMethod->arguments_.size(); i++) {
		                pArg = pMethod->arguments_.at(i);
		                methodConditionStr += pArg->variable_;
		                if (i < pMethod->arguments_.size() - 1) {
		                    methodConditionStr += pArg->variable_ += ",";
		                }
		            }
		            methodConditionStr += ");\n";
		            methodConditionStr +=
		                    "\t\tbyte[] serialized" + pMethod->returnType_ + " = " + lowerCaseReturnType + ".serialize();\n";
		            methodConditionStr += "\t\tresponse.setStatusCode((byte) 100);\n";
		            methodConditionStr += "\t\tresponse.setData(serialized" + pMethod->returnType_ + ");\n";
		            methodConditionStr += "\t\tresponse.setLength(serialized" + pMethod->returnType_ + ".length + 1);\n";
		            methodConditionStr += "\t\treturn response;\n";
		            methodConditionStr += "\t}";

		        }
		        replacableRequestHandlerTmpStr.replace(replacableRequestHandlerTmpStr.find("[%METHOD_CONDITIONS%]"), 21,
		                                               methodConditionStr);
		        os.write(replacableRequestHandlerTmpStr.c_str(), replacableRequestHandlerTmpStr.size());
		        os.close();
		    }
		}

		void
		JavaGenerator::GenerateServiceProxy(::naeem::hottentot::generator::ds::Module *pModule) {
		    ::naeem::hottentot::generator::ds::Service *pService;
		    std::string basePackageName = pModule->package_;
		    for (int i = 0; i < pModule->services_.size(); i++) {
		        std::string replacableServiceProxyStrTmp = serviceProxyTmpStr_;
		        pService = pModule->services_.at(i);
		        std::string path = outDir_ + "/" + pService->name_.c_str() + "ServiceProxy.java";
		        os.open(path.c_str() , std::ios::trunc);
		        pService = pModule->services_.at(i);
		        while(replacableServiceProxyStrTmp.find("[%BASE_PACKAGE_NAME%]") != std::string::npos){
		         	replacableServiceProxyStrTmp.replace(replacableServiceProxyStrTmp.find("[%BASE_PACKAGE_NAME%]"), 21, basePackageName);	
		        }
		        while(replacableServiceProxyStrTmp.find("[%SERVICE_NAME%]") != std::string::npos){
		         	replacableServiceProxyStrTmp.replace(replacableServiceProxyStrTmp.find("[%SERVICE_NAME%]"), 16 , pService->name_);	
		        }

		        //loop on service methods
		        ::naeem::hottentot::generator::ds::Method *pMethod;
		        std::string methodsStr;
		        for (int i = 0; i < pService->methods_.size(); i++) {
		            pMethod =  pService->methods_.at(i);
		            pMethod = pService->methods_.at(i);
		            methodsStr += "public " + pMethod->returnType_ + " " + pMethod->name_ + "(";
		            ::naeem::hottentot::generator::ds::Argument *pArg;
		            for (int i = 0; i < pMethod->arguments_.size(); i++) {

		                pArg = pMethod->arguments_.at(i);
		                methodsStr += pArg->type_ + " " + pArg->variable_;
		                if (i < pMethod->arguments_.size() - 1) {
		                    methodsStr += ",";
		                }
		            }
		            methodsStr += ") { \n";
		            for (int i = 0; i < pMethod->arguments_.size(); i++) {
		                methodsStr += "\t\t//serialize " + pArg->variable_ + "\n";
		                methodsStr += "\t\tbyte[] serialized" + pArg->type_ + " = " + pArg->variable_ + ".serialize();\n";
		            }
		            methodsStr += "\n";
		            methodsStr += "\t\t//make request\n";
		            methodsStr += "\t\tRequest request = new Request();\n";
		            std::stringstream serviceId;
		            //TODO(alisharifi) make service id by hashing
		            //serviceId << pService->id_;
		            serviceId << "1";
		            methodsStr += "\t\trequest.setServiceId((byte) " + serviceId.str() + ");\n";
		            std::stringstream methodId;
		            //TODO(alisharifi) make method id by hashing
		            //methodId << pMethod->id_;
		            methodId << "1";
		            methodsStr += "\t\trequest.setMethodId((byte) " + methodId.str() + ");\n";
		            std::stringstream argSize;
		            argSize << pMethod->arguments_.size();
		            methodsStr += "\t\trequest.setArgumentCount((byte) " + argSize.str() + ");\n";
		            methodsStr += "\t\trequest.setType(Request.RequestType.";
		            
		            //std::cout << pService->serviceType_;
		            if(pService->serviceType_ == 0) {
		                methodsStr += "InvokeStateless";
		            }else if(pService->serviceType_ == 1){
		                methodsStr += "InvokeStatefull";
		            }
		            methodsStr += ");\n";
		            for (int i = 0; i < pMethod->arguments_.size(); i++) {
		                std::stringstream ssI;
		                pArg = pMethod->arguments_.at(i);
		                ssI << i;
		                methodsStr += "\t\tArgument arg" + ssI.str() + " = new Argument();\n";
		                methodsStr += "\t\targ" + ssI.str() + ".setDataLength(" + pArg->variable_.c_str() + ".serialize().length);\n";
		                methodsStr += "\t\targ" + ssI.str() + ".setData(" + pArg->variable_.c_str() + ".serialize());\n";
		                methodsStr += "\t\trequest.addArgument(arg" + ssI.str() + ");\n";
		            }
		            //calculate request length
		            methodsStr += "\t\tint dataLength = 0;\n";
		            methodsStr += "\t\t//calculate data length for every argument\n";
		            for(int i= 0 ; i < pMethod->arguments_.size() ; i++){
		                pArg = pMethod->arguments_.at(i);
		                std::string argDataLengthVarName =  pArg->variable_ + "DataLength";
		                std::string argDataLengthByteArrayLengthVarName =  pArg->variable_ + "DataLengthByteArrayLength";
		                methodsStr += "\t\t//calulate " + argDataLengthVarName + "\n";
		                methodsStr += "\t\tint " + argDataLengthVarName + "= serialized" + pArg->type_ + ".length;\n";
		                methodsStr += "\t\tint " + argDataLengthByteArrayLengthVarName + " = 1;\n";
		                methodsStr += "\t\tif (" + argDataLengthVarName + " >= 0x80) {\n";
		                methodsStr += "\t\t\tif (" + argDataLengthVarName + " <= 0xff) {\n";
		                methodsStr += "\t\t\t\t//ex 0x81 0xff\n";
		                methodsStr += "\t\t\t\t" + argDataLengthByteArrayLengthVarName + " = 2;\n";
		                methodsStr += "\t\t\t} else if (" + argDataLengthVarName + " <= 0xffff) {\n";
		                methodsStr += "\t\t\t\t//ex 0x82 0xff 0xff\n";
		                methodsStr += "\t\t\t\t" + argDataLengthByteArrayLengthVarName + " = 3;\n";
		                methodsStr += "\t\t\t} else if (" + argDataLengthVarName + " <= 0xffffff) {\n";
		                methodsStr += "\t\t\t\t//ex 0x83 0xff 0xff 0xff\n";
		                methodsStr += "\t\t\t\t" + argDataLengthByteArrayLengthVarName + " = 4;\n";
		                methodsStr += "\t\t\t}\n";
		                methodsStr += "\t\t}\n";
		                methodsStr += "\t\tdataLength += " + argDataLengthVarName + " + " + argDataLengthByteArrayLengthVarName + ";\n";
		            }
		            methodsStr += "\t\t//\n";
		            methodsStr += "\t\trequest.setLength(4 + dataLength);\n";
		            methodsStr += "\t\t//connect to server\n";
		            methodsStr += "\t\tTcpClient tcpClient = TcpClientFactory.create();\n";
		            methodsStr += "\t\ttry{\n";
		            methodsStr += "\t\t\ttcpClient.connect(host, port);\n";
		            methodsStr += "\t\t} catch (TcpClientConnectException e) {\n";
		            methodsStr += "\t\t\tthrow new HottentotRuntimeException(e);\n";
		            methodsStr += "\t\t}\n";
		            methodsStr += "\t\t//serialize request according to HTNP\n";
		            methodsStr += "\t\tProtocol protocol = ProtocolFactory.create();\n";
		            methodsStr += "\t\tbyte[] serializedRequest = protocol.serializeRequest(request);\n";
		            methodsStr += "\t\t//send request\n";
		            methodsStr += "\t\ttry {\n";
		            methodsStr += "\t\t\ttcpClient.write(serializedRequest);\n";
		            methodsStr += "\t\t} catch (TcpClientWriteException e) {\n";
		            methodsStr += "\t\t\tthrow new HottentotRuntimeException(e);\n";
		            methodsStr += "\t\t}\n";
		            methodsStr += "\t\t//read response from server\n";
		            methodsStr += "\t\tbyte[] buffer = new byte[256];\n";
		            methodsStr += "\t\twhile (!protocol.IsResponseComplete()) {\n";
		            methodsStr += "\t\t\tbyte[] dataChunkRead;\n";
		            methodsStr += "\t\t\ttry {\n";
		            methodsStr += "\t\t\t\tdataChunkRead = tcpClient.read();\n";
					methodsStr += "\t\t\t} catch (TcpClientReadException e) {\n";
		            methodsStr += "\t\t\t\tthrow new HottentotRuntimeException(e);\n";
		            methodsStr += "\t\t\t}\n";
		            methodsStr += "\t\t\tprotocol.processDataForResponse(dataChunkRead);\n";
		            methodsStr += "\t\t}\n";
		            methodsStr += "\t\t//deserialize token part of response\n";
		            methodsStr += "\t\tResponse response = protocol.getResponse();\n";
		            methodsStr += "\t\t//close everything\n";
		            methodsStr += "\t\t//deserialize " + pMethod->returnType_ +  "part from response\n";
		            std::string lowerCaseReturnType = pMethod->returnType_;
		            lowerCaseReturnType[0] += 32;
		            methodsStr += "\t\t"+pMethod->returnType_ + " " + lowerCaseReturnType + "= null;\n";
		            methodsStr += "\t\tif (response.getStatusCode() == -1) {\n";
		            methodsStr += "\t\t\t//\n";
		            methodsStr += "\t\t} else {\n";
		            methodsStr += "\t\t\t" + lowerCaseReturnType + "= new " + pMethod->returnType_ + "();\n";
		            methodsStr += "\t\t\t" + lowerCaseReturnType + ".deserialize(response.getData());\n";
		            methodsStr += "\t\t}\n";
		            methodsStr += "\t\treturn " + lowerCaseReturnType + ";\n";
		            methodsStr += "\t}\n";
		        }
		        replacableServiceProxyStrTmp.replace(replacableServiceProxyStrTmp.find("[%METHODS%]"),11,methodsStr);
		        os.write(replacableServiceProxyStrTmp.c_str(), replacableServiceProxyStrTmp.size());
		        os.close();
		    }
		}	
      }
    }
  }
}
