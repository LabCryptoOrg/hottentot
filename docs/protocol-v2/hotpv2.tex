\documentclass[10pt,a4paper]{article}
\usepackage{titling}
\usepackage[margin=1 in]{geometry}
\usepackage{graphicx}
\usepackage{listings}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{indentfirst}
\graphicspath{{.}}
\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\newcommand{\subtitle}[1]{%
  \posttitle{%
    \par\end{center}
    \begin{center}\large#1\end{center}
    \vskip0.5em}%
}
\makeatletter
\renewcommand\paragraph{\@startsection{paragraph}{4}{\z@}%
            {-2.5ex\@plus -1ex \@minus -.25ex}%
            {1.25ex \@plus .25ex}%
            {\normalfont\normalsize\bfseries}}
\makeatother

\begin{document}

\title{\vspace{-3cm}Hot Protocol Version 2 (HotPv2)}
\subtitle{Hottentot RPC Framework}
\author{Kamran Amini}

\maketitle

\rule{15cm}{0.4pt}

\tableofcontents
\newpage

\section{Introduction}
This document talks about request and response structures and mechanisms in Hottentot RPC Framework. Purpose of this protocol is to convey Method Invocation request and response. Current protocol is serialization transparent and can convey a method call with arguments produced with different serialization algorithms. In this version, Hottentot's runtimes can only work with internal serialization mechanism.

\section{Glossary}
  \bigskip
  \textbf {SERIALIZATION} \\ \indent {A process in which an object turns into a byte array to be transferred using a channel.} \\\\
  \textbf {STRUCT} \\ \indent {A term used for encapsulation of fields related to a specific entity. It is a structure and it will be generated differently for each programming language.} \\\\
  \textbf {IDL (INTERFACE DEFINITION LANGUAGE)} \\ \indent {An IDL is a language transparent to all programming languages which Hottentot supports. IDL can be generated to any target languages supported by Hottentot RPC Framework.} \\\\
  \textbf {HOT FILE} \\ \indent {A file which contains IDL. Hot files usually end with \texttt{.hot} extension.} \\\\
  \textbf {GENERATOR} \\ \indent {A tool for generating stub and struct source codes for a target programming language. Currently, generators for C++ and Java languages are available.} \\\\
  \textbf {RUNTIME} \\ \indent {A library for a specific programming language which performs Service and Proxy operations. Currently, runtimes are only available for C++ and Java.} \\\\
  \textbf {ENDPOINT} \\ \indent {Endpoint is a combination of IP address and a port. One service object or many can be bound to an endpoint.} \\\\
  \textbf {CURRENT ENDPOINT} \\ \indent {When talking about a proxy, Current Endpoint is an endpoint which client has used for connecting to service-side.} \\\\
  \textbf {SERVICE} \\ \indent {Service is an object serving method invocation requests.} \\\\
  \textbf {PROXY} \\ \indent {Proxy is an object which produces method invocation and other types of requests and receives the response. A proxy object talks to an endpoint at first and its request will be delegated to a service object in case of method invocation requests.} \\\\
  \textbf {PROXY-SIDE} \\ \indent {A software or library which tries to interact with service-side objects like endpoints, services, etc.} \\\\
  \textbf {SERVICE-SIDE} \\ \indent {A software or library which serves proxy-side requests and generates suitable response.} \\\\
  \textbf{PUBLIC KEY INFRASTRUCTURE (PKI)} \\ \indent {An infrastructure built on top of specific asymmetric cryptography mechanisms and schemes to provide security solutions to known security issues.} \\\\
  \textbf{CONVERSATION} \\ \indent {Transfer of messages between proxy-side and service-side in a Hottentot connection.} \\\\


\section{Protocol V2}
Protocol version 2 introduces new features to protocol version 1 in many aspects. Following sections talk about differences and new features in this version.

\subsection{Connection Properties}
Hottentot connections uses Session layer and Application layer in OSI model. Hottnetot SHOULD use \textit {Secure Socket Library} for \textit{Authentication} and \textit{Encryption} purposes.

\subsubsection{Transport}
Hottentot SHOULD support TCP for its transport protocol. That's because of long payloads which need sequencing feature in transport layer. Hottentot MAY work with other transport protocols offering sequencing feature and this MAY be up to operating system to handle transport operations.

\subsubsection{Type of Communication}
Like version 1, communication in protocol version 2 SHOULD start with a request from proxy-side. In this version, service-side SHOULD NOT start the communication. This would be a future feature with its limitations. KeepAlive feature SHOULD BE supported and connection SHOULD remain active by service-side after sending the response if KeepAlive is requested by proxy-side. A Hottentot conversation SHOULD start with \textbf{Handshake} messages. Details about the handshake phase will be discussed in next section.

\subsubsection{Error Detection}
There is no error detection mechanism in this version. We trust underlying protocols like TCP for detecting errors found in the transimtted data. It's obvious that using some security features like SSL provides some tools for detection of communication errors but it is OPTIONAL.

\subsubsection{Security}
Default behaviour SHOULD use plain transfer of data. This means that security features are optional and they should be enabled by user using configurations. Following sections talk about different aspects of security concerns regarding the Hottentot communication. It is clear that default behaviour does not prevent none of following issues.

\paragraph{Eavesdropping}
In order to prevent eavesdropping, Hottentot SHOULD use \textit{Encryption}. Symmetric encryption SHOULD be enough but key distribution phase SHOULD use asymmetric cryptography. Any means necessary for implementing the eavesdropping prevention mechanism SHOULD be used in this scenario; examples of such means are certificates, public and private key pairs, etc.

\paragraph{Injection}
In order to prevent any external party to inject data in a communication channel, Hottentot SHOULD use \textit{Digital Signature} mechanism. A Digital Signature mechanism needs a deployed PKI in order to provide certificates and key pairs for authenticated parties. Hottentot requests and responses MAY carry Digital Signature of request data to assure other parties that data is not changed while transferring.

\paragraph{Authentication}
In order to provide authentication for parties, Hottentot SHOULD use asymmetric cryptography and PKI compliant certificates.

\subsubsection{State Management}
Communications SHOULD be stateless. States related to service objects SHOULD be retained from the request payload. Stateful objects are not supported in this version.


\subsection{Handshake Phase}
As stated before, a Hottentot conversation SHOULD start with \textit{Handshake} messages. Handshakes are performed to let the parties know more about each other and plan for a successful communication. Security objects like Certificates or Encryption Keys are transferred in this phase and the rest of conversation should be set up according to data gathered in handshake phase. Since connections SHOULD start from proxy-side, first message or \textit{Syn Message} SHOULD be sent from proxy-side application. Notice that, this handshake is specific to Hottentot and has nothing to do with other possible handshakes in the system e.g SSL handshakes or TCP handshakes.

\subsubsection{Messages}
Handshake phase consists of 3 messages. First message or \textit{Syn Message} SHOULD be sent by proxy-side who wants to start the conversation with service-side endpoint. Second message or \textit{Ack Message} SHOULD be sent back by service-side in response to first message. Last message or \textit{Commit Message} SHOULD be sent by proxy-side in order to confirm the conversation or reject it. Once 3 messages are transferred and conversation gets confirmed by proxy-side, request message SHOULD be sent by proxy-side application and it SHOULD wait for the response. Please note that, Hottentot handshake SHOULD be performed after all underlying handshakes. If Hottentot is configured to use SSL, TCP handshake and SSL handshake should be completed before Hottentot handshake takes place. Details about the handshake messages will come in next sections.

\paragraph{Syn Message}
Handshake request message has following fields:
\begin{itemize}
  \item Hottentot Protocol Major Version, \texttt{fixed length 1 byte}
  \item Hottentot Protocol Minor Version, \texttt{fixed length 1 byte}
  \item Flag byte, \texttt{fixed length 1 byte}
  \begin{itemize}
    \item \texttt{KeepAlive} flag, bit 0
    \item Bits from 1 to 7 are reserved for future usage.
  \end{itemize}
  \item Reserved, \texttt{fixed length 2 bytes}
  \item \texttt{Array} of supported \texttt{SerializationAlgorithms}, variable length (See Structures \\ section for \texttt{SerializationAlgorithm})
  \item \texttt{Array} of proxy-side \texttt{Certificates}, variable length (See Structures section for \texttt{Certificate})  
\end{itemize}

If \texttt{KeepAlive} flag is set to 1, service-side SHOULD keep connection active after sending back responses. If client is not responsive, the timeout occurs and connection SHOULD be closed by service-side application.

\paragraph{Ack Message}

\paragraph{Commit Message}


\subsection{Request}
Each request consists of 1 mandatory and 2 optional fields.
\begin{itemize}
  \item \textbf{Request Type}: This field is mandatory. Using this field determines type of request.
  \item \textbf{Payload}: This field is optional and carries all necessary data to perform the request operation.
  \item \textbf{Request Digital Signature} This field is optional and carries a PKI compliant digital signature over Request Type and Payload.
\end{itemize} 
Please notice that, there is no checksum or error detection block involved in request structure. This means that we trust underlying network connection for handling communication errors. Also security concerns like impersonation, eavesdropping or on-wire injection will not be discussed here. There is a dedicated chapter for explaining security issues and detailed provided solutions. Below figure shows the request structure.

\begin{figure}[!ht]
  \caption{HotPv2 Request Structure}
  \centering
    \scalebox{2.1}{\includegraphics [width=0.5\textwidth]{hotpv2__request-type.png}}
\end{figure}

\subsubsection{Request Type}
Determines the request type and payload structure. Following C enumeration shows the possible values for this field.

\begin{verbatim}
enum RequestType { 
  Unknown = 0x00, 
  ServiceListQuery = 0x01, 
  MethodInvocation = 0x02,
  MethodListQuery = 0x03,
  ServiceInfoQuery = 0x04,
  MethodInfoQuery = 0x05,
  EndpointInfoQuery = 0x06
};
\end{verbatim}

\noindent
Values can be:
\begin{itemize}
  \item \textbf{Unknown}: It means nothing to Hottentot service side and these requests should be ignored by implementation.
  \item \textbf{ServiceListQuery}: Proxy-side queries about the list of available services. Hottentot service runtime should return list of services exposed on current endpoint.
  \item \textbf{MethodInvocation}: Invokes a method on a specific service object.
  \item \textbf{MethodListQuery}: Proxy-side queries about the list of callable methods on a specific service object.
  \item \textbf{ServiceInfoQuery}: Proxy-side asks about parameters of a specific service.
  \item \textbf{MethodInfoQuery}: Proxy-side asks about parameters of a specific method.
  \item \textbf{EndpointInfoQuery}: Proxy-side asks about parameters of current endpoint.
\end{itemize}

\subsubsection{Payloads}
Requests can have payloads. Many request types need data for their operations and payload carries the data. Following sections explain about payload structure for each request type. Please notice that, any needed piece of information or security object for authentication and authorization purposes will not be included in payloads and these objects will be transferred in \textit{Handshake} phase.

\paragraph{Payload for \textit{Service List Query} Request Type}
A \textit{Service List Query} request has no payload. In other words, this request has only one byte carrying value 0x01 as \textit{Service List Query} request type identifier.

\begin{figure}[!ht]
  \caption{Structure of a Service List Query request.}
  \centering
    \scalebox{1.2}{\includegraphics [width=0.5\textwidth]{hotpv2__service-list-query-request.png}}
\end{figure}

\paragraph{Payload for \textit{Method Invocation} Request Type}
A \textit{Method Invocation} request payload consists of following fields:
\begin{itemize}
  \item Service Id (4 Bytes)
  \item Method Id (4 Bytes)
  \item Number of Arguments (1 Byte)
  \item Arguments as an array of LV Structures. (Variable Length)
\end{itemize}

\begin{figure}[!ht]
  \caption{HotPv2 Method Invocation Request Structure}
  \centering
    \scalebox{2.1}{\includegraphics [width=0.5\textwidth]{hotpv2__method-invocation-request.png}}
\end{figure}

Figure 2 shows the structure of a request. Arguments can be transferred using LV structures. LV structures include Length and Value. Maximum length for a single LV structure is $2^{32} - 1$ since length values can be stored in a field at most 4 bytes. Figure 3 shows the LV structures in detail.

\begin{figure}[!ht]
  \caption{Structure of a Method Invocation request payload with arguments' LV structures.}
  \centering
    \scalebox{2.2}{\includegraphics [width=0.5\textwidth]{hotpv2__method-invocation-request-payload-lv-structures.png}}
\end{figure}

Value can be any byte array but usually it is a serialized object. Serialization method can be anything. Hottentot itself provides an algorithm for serialization and \texttt {serialize()} and \texttt {deserialize()} methods are generated for every struct. Current stub generation mechanism works only with Hottentot's internal serialization.

\paragraph{Payload for \textit{Method List Query} Request Type} 
A \textit{Method List Query} request has following fields:
\begin{itemize}
  \item Service Id (4 Bytes)
\end{itemize}
This will return list of methods available on a service object identified by \textit{Service Id}.

\begin{figure}[!ht]
  \caption{Structure of a Method List Query request.}
  \centering
    \scalebox{1.5}{\includegraphics [width=0.5\textwidth]{hotpv2__method-list-query-request.png}}
\end{figure}

\paragraph{Payload for \textit{Service Info Query} Request Type} 
A \textit{Service Info Query} request has following fields:
\begin{itemize}
  \item Service Id (4 Bytes)
\end{itemize}
This will return the parameters and their values for a service object identified by \textit{Service Id}. Parameters and values are serialized according to LV structures. Structure for service parameters will be explained in future chapters.

\begin{figure}[!ht]
  \caption{Structure of a Service Info Query request.}
  \centering
    \scalebox{1.5}{\includegraphics [width=0.5\textwidth]{hotpv2__service-info-query-request.png}}
\end{figure}

\paragraph{Payload for \textit{Method Info Query} Request Type} 
A \textit{Method Info Query} request has following fields:
\begin{itemize}
  \item Service Id (4 Bytes)
  \item Method Id (4 Bytes)
\end{itemize}
This will return the parameters and their values for a method identified by \textit{Method Id} on a specific service object identified by \textit{Service Id}. Parameters and values are serialized according to LV structures. Structure for method parameters will be explained in future chapters.

\begin{figure}[!ht]
  \caption{Structure of a Method Info Query request.}
  \centering
    \scalebox{1.5}{\includegraphics [width=0.5\textwidth]{hotpv2__method-info-query-request.png}}
\end{figure}

\paragraph{Payload for \textit{Endpoint Info Query} Request Type} 
A \textit{Endpoint Info Query} request has no fields, hence we have no payload. Parameters of current endpoint selected by proxy-side will be returned as response. Parameters are serialized according to LV structures.

\begin{figure}[!ht]
  \caption{Structure of a Endpoint Info Query request.}
  \centering
    \scalebox{1.2}{\includegraphics [width=0.5\textwidth]{hotpv2__endpoint-info-query-request.png}}
\end{figure}

\section{Structures}

\section{Algorithms}

\subsection{Fast Hash Algorithm}
A fast hashing algorithm developed by Zilong Tan. It has 2 versions. One version generates 32-bit has value for a given byte array and the other one generates a 64-bit hash value for the input. Hottentot uses 32-bit fast hash algorithm for generating system independent identifiers (ids) for services and methods. We denote this algorithm with $ FH_{32} $ and $ FH_{64} $ throughout this document.

\begin{equation}
\begin{split}
  FH_{32}: \{0, 1\}^* \to \{0, 1\}^{32}  \\
  FH_{64}: \{0, 1\}^* \to \{0, 1\}^{64}
\end{split}
\end{equation}


\section{Future Features}
\begin{itemize}
  \item Version should be added to request and response structures.
\end{itemize}

\end{document}